
/*
 * CPQ
 *
 * CPQ Web API Documentation
 *
 * API version: 2.9.1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type CatalogServicesRequestsApiService service

/* 
CatalogServicesRequestsApiService
This API is responsible for fetching a list of classified products eligible for selection by a customer from catalog services, for a specific classificationRootId. The returned list of products can be used for selection and addition to the quote based on the customers choice.&lt;br/&gt; If a failed response is returned by the API, the responseCode value contains:  responseCode | Meaning   --- | ----   CSConnectionRequestError | The request was sent to Catalog Services and failed in this component.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param classificationRootId Classification root ID&lt;br/&gt;Example:TSales_Channel
 * @param optional nil or *CatalogServicesRequestsApiApiClassificationsClassificationRootIdGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return ClassificationsObject
*/

type CatalogServicesRequestsApiApiClassificationsClassificationRootIdGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *CatalogServicesRequestsApiService) ApiClassificationsClassificationRootIdGet(ctx context.Context, classificationRootId string, localVarOptionals *CatalogServicesRequestsApiApiClassificationsClassificationRootIdGetOpts) (ClassificationsObject, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ClassificationsObject
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/classifications/{classificationRootId}"
	localVarPath = strings.Replace(localVarPath, "{"+"classificationRootId"+"}", fmt.Sprintf("%v", classificationRootId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ClassificationsObject
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v GetClassificationsRestResponse500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
CatalogServicesRequestsApiService
Gets the catalog defined offer specification for the entity with the specified Id. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param entityId entity ID
 * @param optional nil or *CatalogServicesRequestsApiApiEntitiesEntityIdGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return ProductSpecObject
*/

type CatalogServicesRequestsApiApiEntitiesEntityIdGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *CatalogServicesRequestsApiService) ApiEntitiesEntityIdGet(ctx context.Context, entityId string, localVarOptionals *CatalogServicesRequestsApiApiEntitiesEntityIdGetOpts) (ProductSpecObject, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ProductSpecObject
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/entities/{entityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"entityId"+"}", fmt.Sprintf("%v", entityId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ProductSpecObject
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
CatalogServicesRequestsApiService
Gets the metadata for the entity with the specified Id. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param entityId entity ID
 * @param optional nil or *CatalogServicesRequestsApiApiEntitiesMetaDataEntityIdGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return ProductSpecObject
*/

type CatalogServicesRequestsApiApiEntitiesMetaDataEntityIdGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *CatalogServicesRequestsApiService) ApiEntitiesMetaDataEntityIdGet(ctx context.Context, entityId string, localVarOptionals *CatalogServicesRequestsApiApiEntitiesMetaDataEntityIdGetOpts) (ProductSpecObject, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ProductSpecObject
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/entities/metaData/{entityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"entityId"+"}", fmt.Sprintf("%v", entityId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ProductSpecObject
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
CatalogServicesRequestsApiService
Retrieve a collection of entities which match the supplied instance types that are available on the date specified. If no date is specified it defaults to today&#39;s date. An example of the call would look like:&lt;br/&gt;&lt;br/&gt;&lt;b&gt;/api/offers/byType?InstanceTypeNames&#x3D;Package&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;Please note that this is an example only, and should not be used in production.&lt;br/&gt;&lt;br/&gt;Please also note that only the top level properties defined on each entity are returned - no properties which are child entities or charges are returned.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param instanceTypeNames Comma separated list of entity types you would like returned. These can include&lt;br/&gt; Package,Bundle Promotion etc. Note that these types must be specified with the first letter capitalised
 * @param optional nil or *CatalogServicesRequestsApiApiOffersByTypeGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "TargetDate" (optional.String) -  The date in YYYY-MM-DD format which represents the date that the returned entities are marked as available (ie between AvailableStartDate and AvailableEndDate. If this parameter is not specified then it defaults to today&#39;s date.

@return GetOffersByTypeResponse
*/

type CatalogServicesRequestsApiApiOffersByTypeGetOpts struct { 
	ClientRequestSource optional.String
	TargetDate optional.String
}

func (a *CatalogServicesRequestsApiService) ApiOffersByTypeGet(ctx context.Context, instanceTypeNames string, localVarOptionals *CatalogServicesRequestsApiApiOffersByTypeGetOpts) (GetOffersByTypeResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GetOffersByTypeResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/offers/byType"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("InstanceTypeNames", parameterToString(instanceTypeNames, ""))
	if localVarOptionals != nil && localVarOptionals.TargetDate.IsSet() {
		localVarQueryParams.Add("targetDate", parameterToString(localVarOptionals.TargetDate.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v GetOffersByTypeResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
CatalogServicesRequestsApiService
Retrieve the offers which match the supplied classifications, facts, characteristics or categories. A fully populated endpoint would look like:&lt;br/&gt;&lt;br/&gt;&lt;b&gt;/api/offers?InstanceTypeNames&#x3D;Package&amp;Classifications&#x3D;[TSales_Channel_Classification;e4a2a606-501f-f009-731a-64ba27c59d50;false]&amp;ClassificationElementName&#x3D;TSales_Channel_Classification&amp;FactElementFilter&#x3D;[Lookup_Colour;fed70bc9-c12d-4875-b2d3-e1930992440e;false]&amp;Categories&#x3D;[22,18;true]&amp;Characteristics&#x3D;[Lookup_Colour;846fa97b-b9a5-4671-9660-f3b0d554da4b;false]&amp;xsltCode&#x3D;offer_short&amp;at[p1]&#x3D;ID&amp;el[p2]&#x3D;name&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;Please note that this is an example only, and should not be used in production.&lt;br/&gt;
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param instanceTypeNames Comma separated list of entity types you would like returned. These can include&lt;br/&gt; Package,Bundle Promotion etc. Note that these types must be specified with the first letter capitalised
 * @param classificationElementName That name of the element on each entity you wish returned that is of the Classification type specified in the data packets
 * @param classifications A list of classification packets that define which classification on which to match. Each packet has the following format:&lt;br/&gt;[classificationElementName; classificationGuids; MatchAllClassification]&lt;br/&gt;CLASSIFICATIONELEMENTNAME is the name of the schema element that holds the Classifications on which they query is filtering.&lt;br/&gt;CLASSIFICATIONGUIDS is a comma-separated list that represents all the Classifications on which the query is filtering.&lt;br/&gt;MATCHALLCLASSIFICATION is either TRUE or FALSE to specify whether the query results need to match ALL of these or just ANY. You can pass multiple packets into this query.
 * @param xsltCode The code of the XSLT stored in the Catalog Services database that transforms the XML output into a desired format. This is required and must return data in the required format.
 * @param optional nil or *CatalogServicesRequestsApiApiOffersGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "Characteristics" (optional.String) -  A list of characteristic packets that define the characteristic on which you want to match, with each packet in the following format:&lt;br/&gt;[characteristicElementName; characteristicGuids; MatchAllCharacteristics]&lt;br/&gt;CHARACTERISTICELEMENTNAME is the name of the schema element that holds the characteristics on which they query is filtering.&lt;br/&gt;         CHARACTERISTICGUIDS is a comma-separated list that represents all the characteristics on which the query is filtering.&lt;br/&gt;MATCHALLCHARACTERISTICS is either TRUE or FALSE to specify whether the query results need to match ALL of these or just ANY. You can pass multiple packets into this query.&lt;br/&gt;Add multiple characteristic and classification packets by appending each element set inside square brackets ([ ]). Combine each additional packet with the others using AND logic to specify that all must match.
     * @param "FactElementFilter" (optional.String) -  A list of fact values for those on which you want to query to match. Each packet takes the following format:&lt;br/&gt;[FactValue; FactValueGuids; MatchAllFactValues]&lt;br /&gt;FACTVALUE is the name of the schema element that holds the fact value on which you are filtering.&lt;br/&gt; FACTVALUEGUIDS is a comma-separated list of GUIDs representing the fact values on which you are filtering. &lt;br/&gt;MATCHALLFACTVALUES is a true or false value indicating whether the query matches on ALL fact values or just ANY fact values.Note: You can pass multiple fact value packets in this query.
     * @param "Categories" (optional.String) -  A data packet which takes the following format: &lt;br/&gt;[Categories;IncludeChildCategories].&lt;br/&gt; CATEGORIES is a comma separated list of category Ids.&lt;br/&gt; INCLUDECHILDCATEGORIES indicates whether entities should be returned that live in categories that are children of the category Id specified in the CATEGORIES parameter
     * @param "AtP1" (optional.String) -  A parameter in the parameter list for the above XSLT which are used to retrieve values which appear as XML attributes on a matching entity, there can be as many of these as you like as long as each key is unique, only one &#39;p1&#39; property. You cannot have at[p1] and el[p1] every subsequent parameter should be incremented
     * @param "ElP1" (optional.String) -  A parameter in the parameter list for the above XSLT which are used to retrieve values which appear as XML attributes on a matching entity, there can be as many of these as you like as long as each key is unique, only one &#39;p1&#39; property. You cannot have at[p1] and el[p1] every subsequent parameter should be incremented
     * @param "AtP2" (optional.String) -  A parameter in the parameter list for the above XSLT which are used to retrieve values which appear as XML attributes on a matching entity, there can be as many of these as you like as long as each key is unique, only one &#39;p1&#39; property. You cannot have at[p1] and el[p1] every subsequent parameter should be incremented
     * @param "ElP2" (optional.String) -  A parameter in the parameter list for the above XSLT which are used to retrieve values which appear as XML attributes on a matching entity, there can be as many of these as you like as long as each key is unique, only one &#39;p1&#39; property. You cannot have at[p1] and el[p1] every subsequent parameter should be incremented
     * @param "AtP3" (optional.String) -  A parameter in the parameter list for the above XSLT which are used to retrieve values which appear as XML attributes on a matching entity, there can be as many of these as you like as long as each key is unique, only one &#39;p1&#39; property. You cannot have at[p1] and el[p1] every subsequent parameter should be incremented
     * @param "ElP3" (optional.String) -  A parameter in the parameter list for the above XSLT which are used to retrieve values which appear as XML attributes on a matching entity, there can be as many of these as you like as long as each key is unique, only one &#39;p1&#39; property. You cannot have at[p1] and el[p1] every subsequent parameter should be incremented

@return GetOffersByClassificationResponse
*/

type CatalogServicesRequestsApiApiOffersGetOpts struct { 
	ClientRequestSource optional.String
	Characteristics optional.String
	FactElementFilter optional.String
	Categories optional.String
	AtP1 optional.String
	ElP1 optional.String
	AtP2 optional.String
	ElP2 optional.String
	AtP3 optional.String
	ElP3 optional.String
}

func (a *CatalogServicesRequestsApiService) ApiOffersGet(ctx context.Context, instanceTypeNames string, classificationElementName string, classifications string, xsltCode string, localVarOptionals *CatalogServicesRequestsApiApiOffersGetOpts) (GetOffersByClassificationResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GetOffersByClassificationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/offers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("InstanceTypeNames", parameterToString(instanceTypeNames, ""))
	localVarQueryParams.Add("ClassificationElementName", parameterToString(classificationElementName, ""))
	localVarQueryParams.Add("Classifications", parameterToString(classifications, ""))
	if localVarOptionals != nil && localVarOptionals.Characteristics.IsSet() {
		localVarQueryParams.Add("Characteristics", parameterToString(localVarOptionals.Characteristics.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FactElementFilter.IsSet() {
		localVarQueryParams.Add("FactElementFilter", parameterToString(localVarOptionals.FactElementFilter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Categories.IsSet() {
		localVarQueryParams.Add("Categories", parameterToString(localVarOptionals.Categories.Value(), ""))
	}
	localVarQueryParams.Add("xsltCode", parameterToString(xsltCode, ""))
	if localVarOptionals != nil && localVarOptionals.AtP1.IsSet() {
		localVarQueryParams.Add("at[p1]", parameterToString(localVarOptionals.AtP1.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElP1.IsSet() {
		localVarQueryParams.Add("el[p1]", parameterToString(localVarOptionals.ElP1.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AtP2.IsSet() {
		localVarQueryParams.Add("at[p2]", parameterToString(localVarOptionals.AtP2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElP2.IsSet() {
		localVarQueryParams.Add("el[p2]", parameterToString(localVarOptionals.ElP2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AtP3.IsSet() {
		localVarQueryParams.Add("at[p3]", parameterToString(localVarOptionals.AtP3.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElP3.IsSet() {
		localVarQueryParams.Add("el[p3]", parameterToString(localVarOptionals.ElP3.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v GetOffersByClassificationResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
CatalogServicesRequestsApiService
Retrieve the offers which match the supplied classifications, facts, characteristics or categories. The results are not subject to XML transform so specifying any XsltCode or XSLT parameters is not necessary and are ignored if specified.&lt;br/&gt;&lt;br/&gt; A fully populated endpoint would look like:&lt;br/&gt;&lt;br/&gt;&lt;b&gt;/api/offers/untransformed?InstanceTypeNames&#x3D;Package&amp;Classifications&#x3D;[TSales_Channel_Classification;e4a2a606-501f-f009-731a-64ba27c59d50;false]&amp;ClassificationElementName&#x3D;TSales_Channel_Classification&amp;FactElementFilter&#x3D;[Lookup_Colour;fed70bc9-c12d-4875-b2d3-e1930992440e;false]&amp;Categories&#x3D;[22,18;true]&amp;Characteristics&#x3D;[Lookup_Colour;846fa97b-b9a5-4671-9660-f3b0d554da4b;false]&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;Please note that this is an example only, and should not be used in production.&lt;br/&gt;&lt;br/&gt;Please also note that calling this endpoint will result in potentially a very large amount of data being returned depending upon the structure of the models in Catalog and the Instance Types requested.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param instanceTypeNames Comma separated list of entity types you would like returned. These can include&lt;br/&gt; Package,Bundle Promotion etc. Note that these types must be specified with the first letter capitalised
 * @param classificationElementName That name of the element on each entity you wish returned that is of the Classification type specified in the data packets
 * @param classifications A list of classification packets that define which classification on which to match. Each packet has the following format:&lt;br/&gt;[classificationElementName; classificationGuids; MatchAllClassification]&lt;br/&gt;CLASSIFICATIONELEMENTNAME is the name of the schema element that holds the Classifications on which they query is filtering.&lt;br/&gt;CLASSIFICATIONGUIDS is a comma-separated list that represents all the Classifications on which the query is filtering.&lt;br/&gt;MATCHALLCLASSIFICATION is either TRUE or FALSE to specify whether the query results need to match ALL of these or just ANY. You can pass multiple packets into this query.
 * @param optional nil or *CatalogServicesRequestsApiApiOffersUntransformedGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "Characteristics" (optional.String) -  A list of characteristic packets that define the characteristic on which you want to match, with each packet in the following format:&lt;br/&gt;[characteristicElementName; characteristicGuids; MatchAllCharacteristics]&lt;br/&gt;CHARACTERISTICELEMENTNAME is the name of the schema element that holds the characteristics on which they query is filtering.&lt;br/&gt;         CHARACTERISTICGUIDS is a comma-separated list that represents all the characteristics on which the query is filtering.&lt;br/&gt;MATCHALLCHARACTERISTICS is either TRUE or FALSE to specify whether the query results need to match ALL of these or just ANY. You can pass multiple packets into this query.&lt;br/&gt;Add multiple characteristic and classification packets by appending each element set inside square brackets ([ ]). Combine each additional packet with the others using AND logic to specify that all must match.
     * @param "FactElementFilter" (optional.String) -  A list of fact values for those on which you want to query to match. Each packet takes the following format:&lt;br/&gt;[FactValue; FactValueGuids; MatchAllFactValues]&lt;br /&gt;FACTVALUE is the name of the schema element that holds the fact value on which you are filtering.&lt;br/&gt; FACTVALUEGUIDS is a comma-separated list of GUIDs representing the fact values on which you are filtering. &lt;br/&gt;MATCHALLFACTVALUES is a true or false value indicating whether the query matches on ALL fact values or just ANY fact values.Note: You can pass multiple fact value packets in this query.
     * @param "Categories" (optional.String) -  A data packet which takes the following format: &lt;br/&gt;[Categories;IncludeChildCategories].&lt;br/&gt; CATEGORIES is a comma separated list of category Ids.&lt;br/&gt; INCLUDECHILDCATEGORIES indicates whether entities should be returned that live in categories that are children of the category Id specified in the CATEGORIES parameter

@return GetOffersUntransformedResponse
*/

type CatalogServicesRequestsApiApiOffersUntransformedGetOpts struct { 
	ClientRequestSource optional.String
	Characteristics optional.String
	FactElementFilter optional.String
	Categories optional.String
}

func (a *CatalogServicesRequestsApiService) ApiOffersUntransformedGet(ctx context.Context, instanceTypeNames string, classificationElementName string, classifications string, localVarOptionals *CatalogServicesRequestsApiApiOffersUntransformedGetOpts) (GetOffersUntransformedResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GetOffersUntransformedResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/offers/untransformed"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("InstanceTypeNames", parameterToString(instanceTypeNames, ""))
	localVarQueryParams.Add("ClassificationElementName", parameterToString(classificationElementName, ""))
	localVarQueryParams.Add("Classifications", parameterToString(classifications, ""))
	if localVarOptionals != nil && localVarOptionals.Characteristics.IsSet() {
		localVarQueryParams.Add("Characteristics", parameterToString(localVarOptionals.Characteristics.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FactElementFilter.IsSet() {
		localVarQueryParams.Add("FactElementFilter", parameterToString(localVarOptionals.FactElementFilter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Categories.IsSet() {
		localVarQueryParams.Add("Categories", parameterToString(localVarOptionals.Categories.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v GetOffersUntransformedResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
