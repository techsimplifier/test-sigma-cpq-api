
/*
 * CPQ
 *
 * CPQ Web API Documentation
 *
 * API version: 2.9.1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type WorkflowApiService service

/* 
WorkflowApiService
For the specified state machine, retrieve a listing of all of the statuses that have been registered and also include a count of all framework contracts which are currently of those statuses
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param stateMachine The name of the state machine whose statuses are to be queried
 * @param optional nil or *WorkflowApiApiWorkflowStateMachineStatesGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "CpqLanguage" (optional.String) -  The language code (in ISO 639-1 format) that error messages are to be translated to for returning back to the client. If not supplied it defaults to en-GB


*/

type WorkflowApiApiWorkflowStateMachineStatesGetOpts struct { 
	ClientRequestSource optional.String
	CpqLanguage optional.String
}

func (a *WorkflowApiService) ApiWorkflowStateMachineStatesGet(ctx context.Context, stateMachine string, localVarOptionals *WorkflowApiApiWorkflowStateMachineStatesGetOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/workflow/{stateMachine}/states"
	localVarPath = strings.Replace(localVarPath, "{"+"stateMachine"+"}", fmt.Sprintf("%v", stateMachine), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(stateMachine) < 1 {
		return nil, reportError("stateMachine must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.CpqLanguage.IsSet() {
		localVarHeaderParams["cpq-language"] = parameterToString(localVarOptionals.CpqLanguage.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 401 {
			var v UnauthorizedRequest401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 403 {
			var v GetAllStatesForbiddenError403
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
WorkflowApiService
For the supplied state machine and status return the details on which transitions are possible to select.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param stateMachine The name of the state machine to find valid transitions for
 * @param status The status from which to determine the next allowable transition
 * @param optional nil or *WorkflowApiApiWorkflowStateMachineStatusStatusTransitionsGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "CpqLanguage" (optional.String) -  The language code (in ISO 639-1 format) that error messages are to be translated to for returning back to the client. If not supplied it defaults to en-GB


*/

type WorkflowApiApiWorkflowStateMachineStatusStatusTransitionsGetOpts struct { 
	ClientRequestSource optional.String
	CpqLanguage optional.String
}

func (a *WorkflowApiService) ApiWorkflowStateMachineStatusStatusTransitionsGet(ctx context.Context, stateMachine string, status string, localVarOptionals *WorkflowApiApiWorkflowStateMachineStatusStatusTransitionsGetOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/workflow/{stateMachine}/status/{status}/transitions"
	localVarPath = strings.Replace(localVarPath, "{"+"stateMachine"+"}", fmt.Sprintf("%v", stateMachine), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"status"+"}", fmt.Sprintf("%v", status), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(stateMachine) < 1 {
		return nil, reportError("stateMachine must have at least 1 elements")
	}
	if strlen(status) < 1 {
		return nil, reportError("status must have at least 1 elements")
	}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.CpqLanguage.IsSet() {
		localVarHeaderParams["cpq-language"] = parameterToString(localVarOptionals.CpqLanguage.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 401 {
			var v UnauthorizedRequest401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 403 {
			var v GetAllTransitionsForbiddenError403
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
WorkflowApiService
Execute a transition operation on a state machine to change the status of the documents which are referenced by the identifiers in the request body
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param contentType Specifies the format of the data that is being sent to the API. Only JSON data is accepted
 * @param stateMachine The name of the state machine which represents the documents whose status you wish to change
 * @param transition The name of the transition which is present on the state machine which is responsible for changing the document status
 * @param workflowRequestBody The collection of workflowRequestBody which refer to the documents for their status changed as part of the workflow operation. These workflowRequestBody must have &#39;id&#39; in format (GUID or FC_ID or External OM ID [0-9 digit format]) otherwise an error will be returned .Generalized optional messages body for workflow API transition can be array or array of objects and should contain atleast one element.The messages can be submitted to indicate specific reasons for failure.
 * @param optional nil or *WorkflowApiApiWorkflowStateMachineTransitionTransitionPutOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "CpqLanguage" (optional.String) -  The language code (in ISO 639-1 format) that error messages are to be translated to for returning back to the client. If not supplied it defaults to en-GB
     * @param "IsSimulation" (optional.Bool) -  Determines whether after determining which identifiers are able to transition the changes are written to the database. If specified as true then no changes are made and if specified as false then if possible the database is updated. If not specified this parameter defaults to false
     * @param "AllowPartialTransitions" (optional.Bool) -  If specified as true then at least one identifier has to be able to transition to the target state for the operation to be considered successful. If specified as false then all identifiers have to be able to transition. The default value for this parameter is false.

@return SuccessResponse200
*/

type WorkflowApiApiWorkflowStateMachineTransitionTransitionPutOpts struct { 
	ClientRequestSource optional.String
	CpqLanguage optional.String
	IsSimulation optional.Bool
	AllowPartialTransitions optional.Bool
}

func (a *WorkflowApiService) ApiWorkflowStateMachineTransitionTransitionPut(ctx context.Context, contentType string, stateMachine string, transition string, workflowRequestBody WorkflowRequest, localVarOptionals *WorkflowApiApiWorkflowStateMachineTransitionTransitionPutOpts) (SuccessResponse200, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SuccessResponse200
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/workflow/{stateMachine}/transition/{transition}"
	localVarPath = strings.Replace(localVarPath, "{"+"stateMachine"+"}", fmt.Sprintf("%v", stateMachine), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"transition"+"}", fmt.Sprintf("%v", transition), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(stateMachine) < 1 {
		return localVarReturnValue, nil, reportError("stateMachine must have at least 1 elements")
	}
	if strlen(transition) < 1 {
		return localVarReturnValue, nil, reportError("transition must have at least 1 elements")
	}

	if localVarOptionals != nil && localVarOptionals.IsSimulation.IsSet() {
		localVarQueryParams.Add("isSimulation", parameterToString(localVarOptionals.IsSimulation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AllowPartialTransitions.IsSet() {
		localVarQueryParams.Add("allowPartialTransitions", parameterToString(localVarOptionals.AllowPartialTransitions.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.CpqLanguage.IsSet() {
		localVarHeaderParams["cpq-language"] = parameterToString(localVarOptionals.CpqLanguage.Value(), "")
	}
	localVarHeaderParams["Content-Type"] = parameterToString(contentType, "")
	// body params
	localVarPostBody = &workflowRequestBody
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SuccessResponse200
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v WorkflowValidationError400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 401 {
			var v UnauthorizedRequest401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 403 {
			var v StateMachineTransitionsForbiddenError403
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
