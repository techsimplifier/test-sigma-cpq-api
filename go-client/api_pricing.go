
/*
 * CPQ
 *
 * CPQ Web API Documentation
 *
 * API version: 2.9.1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type PricingApiService service

/* 
PricingApiService
&lt;br/&gt;This API is responsible for pricing the modified Quote Item in the context of a Quote by utilizing the underlying Catalog Services using OrderCandidate pricing services with additional behaviour including the execution of any registered CPQ Pricing Plugins.Importantly the API does not save or commit the passed Quote to the database it is simply priced and returned.&lt;br/&gt;&lt;br/&gt; If a failed response is returned by the API, the responseCode value contains:  responseCode | Meaning   --- | ----   CSConnectionRequestError | The request was sent to Catalog Services and failed in this component.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Supply a valid guid for quoteId and it should be present in the CPQ system &lt;br/&gt;Example:841b8d04-2c18-44c4-aa18-a3ae0fc17558
 * @param quote The modified quote item whose price you wish to obtain.
 * @param optional nil or *PricingApiApiQuotesQuoteIdPriceQuotePostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return Quote
*/

type PricingApiApiQuotesQuoteIdPriceQuotePostOpts struct { 
	ClientRequestSource optional.String
}

func (a *PricingApiService) ApiQuotesQuoteIdPriceQuotePost(ctx context.Context, quoteId string, quote Quote, localVarOptionals *PricingApiApiQuotesQuoteIdPriceQuotePostOpts) (Quote, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Quote
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/priceQuote"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &quote
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Quote
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v PriceQuoteRestResponse400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v PriceQuoteRestResponse500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
PricingApiService
&lt;br/&gt;This API is responsible for pricing a Product Candidate in the context of a Quote by utilizing the underlying Catalog Services pricing services with additional behaviour including the execution of any registered CPQ Pricing Plugins.The pricing response consist of summary of all the charges that the consumer has been charged.Importantly the API does not save or commit the passed Product Candidate to the database it is simply priced and returned.&lt;br/&gt;&lt;br/&gt; If a failed response is returned by the API, the responseCode value contains:  responseCode | Meaning   --- | ----   CSConnectionRequestError | The request was sent to Catalog Services and failed in this component.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Supply a valid guid for quoteId and it should be present in the CPQ system &lt;br/&gt;Example:841b8d04-2c18-44c4-aa18-a3ae0fc17558
 * @param productCandidate The product candidate whose price you wish to obtain.
 * @param optional nil or *PricingApiApiQuotesQuoteIdPricingPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "CpqLanguage" (optional.String) -  The language code (in ISO 639-1 format) that error messages are to be translated to for returning back to the client. If not supplied it defaults to en-GB&lt;br/&gt;Example:en-US

@return ICpqPricingResponse
*/

type PricingApiApiQuotesQuoteIdPricingPostOpts struct { 
	ClientRequestSource optional.String
	CpqLanguage optional.String
}

func (a *PricingApiService) ApiQuotesQuoteIdPricingPost(ctx context.Context, quoteId string, productCandidate ProductCandidateForPricing, localVarOptionals *PricingApiApiQuotesQuoteIdPricingPostOpts) (ICpqPricingResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ICpqPricingResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/pricing"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.CpqLanguage.IsSet() {
		localVarHeaderParams["cpq-language"] = parameterToString(localVarOptionals.CpqLanguage.Value(), "")
	}
	// body params
	localVarPostBody = &productCandidate
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ICpqPricingResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v RestResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
