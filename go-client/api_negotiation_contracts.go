
/*
 * CPQ
 *
 * CPQ Web API Documentation
 *
 * API version: 2.9.1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type NegotiationContractsApiService service

/* 
NegotiationContractsApiService
Clone a framework contract into new copies each of which may contain or not contain the selection rules of the original
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param contentType Specifies the format of the data that is being sent to the API. Only JSON data is accepted
 * @param fcUser The name of the user that is cloning the framework contract rule set
 * @param identifier The identifier of a contract rule set that is to be cloned - can be provided either as a guid value or as a value which matches the pattern ^[a-z0-9]{6}$
 * @param cloneConfigurationItems The configurations which are to be applied to the existing contract to create cloned copies.
 * @param optional nil or *NegotiationContractsApiApiContractsIdentifierClonePostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "CpqLanguage" (optional.String) -  The language code (in ISO 639-1 format) that error messages are to be translated to for returning back to the client. If not supplied it defaults to en-GB
     * @param "Count" (optional.Float32) -  A numeric value indicating how many framework contract clones that are to be created. This value should match the number of elements the clone configuration items array supplied in the request body. If not supplied it is defaulted to 1


*/

type NegotiationContractsApiApiContractsIdentifierClonePostOpts struct { 
	ClientRequestSource optional.String
	CpqLanguage optional.String
	Count optional.Float32
}

func (a *NegotiationContractsApiService) ApiContractsIdentifierClonePost(ctx context.Context, contentType string, fcUser string, identifier string, cloneConfigurationItems CloneContractRequest, localVarOptionals *NegotiationContractsApiApiContractsIdentifierClonePostOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/contracts/{identifier}/clone"
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", fmt.Sprintf("%v", identifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(fcUser) < 1 {
		return nil, reportError("fcUser must have at least 1 elements")
	}
	if strlen(fcUser) > 30 {
		return nil, reportError("fcUser must have less than 30 elements")
	}

	if localVarOptionals != nil && localVarOptionals.Count.IsSet() {
		localVarQueryParams.Add("count", parameterToString(localVarOptionals.Count.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.CpqLanguage.IsSet() {
		localVarHeaderParams["cpq-language"] = parameterToString(localVarOptionals.CpqLanguage.Value(), "")
	}
	localVarHeaderParams["Content-Type"] = parameterToString(contentType, "")
	localVarHeaderParams["fc-user"] = parameterToString(fcUser, "")
	// body params
	localVarPostBody = &cloneConfigurationItems
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NegotiationContractsApiService
Update a framework contract rule and create negotiated specifications for the referenced offering and standalone discount specifications
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param fcUser The name of the user that is creating the framework contract rule set
 * @param identifier The identifier of a contract rule set - can be provided either as a guid value or as a value which matches the pattern ^[a-z0-9]{6}$
 * @param endDate The end date that you wish to set for the contract rule set. The value supplied must conform to ISO 8601 format (YYYY-MM-DD) or (YYYY-MM-DDTHH:mm:ss.SSSZ)
 * @param optional nil or *NegotiationContractsApiApiContractsIdentifierEndDatePutOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "CpqLanguage" (optional.String) -  The language code (in ISO 639-1 format) that error messages are to be translated to for returning back to the client. If not supplied it defaults to en-GB


*/

type NegotiationContractsApiApiContractsIdentifierEndDatePutOpts struct { 
	ClientRequestSource optional.String
	CpqLanguage optional.String
}

func (a *NegotiationContractsApiService) ApiContractsIdentifierEndDatePut(ctx context.Context, fcUser string, identifier string, endDate string, localVarOptionals *NegotiationContractsApiApiContractsIdentifierEndDatePutOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/contracts/{identifier}/endDate"
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", fmt.Sprintf("%v", identifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(fcUser) < 1 {
		return nil, reportError("fcUser must have at least 1 elements")
	}
	if strlen(fcUser) > 30 {
		return nil, reportError("fcUser must have less than 30 elements")
	}

	localVarQueryParams.Add("endDate", parameterToString(endDate, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	localVarHeaderParams["fc-user"] = parameterToString(fcUser, "")
	if localVarOptionals != nil && localVarOptionals.CpqLanguage.IsSet() {
		localVarHeaderParams["cpq-language"] = parameterToString(localVarOptionals.CpqLanguage.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NegotiationContractsApiService
Update a framework contract rule and create negotiated specifications for the referenced offering and standalone discount specifications
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param fcUser The name of the user that is creating the framework contract rule set
 * @param identifier The identifier of a contract rule set - can be provided either as a guid value or as a value which matches the pattern ^[a-z0-9]{6}$
 * @param contract The framework contract rule set in JSON format that is to be written to the database.
 * @param contentType Specifies the format of the data that is being sent to the API. Only JSON data is accepted
 * @param optional nil or *NegotiationContractsApiApiContractsIdentifierPutOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "CpqLanguage" (optional.String) -  The language code (in ISO 639-1 format) that error messages are to be translated to for returning back to the client. If not supplied it defaults to en-GB
     * @param "PerformTransformation" (optional.Bool) -  Perform transformation of referenced product specifications using the given framework contract into transformed specifications or not. If not supplied defaults to true
     * @param "ReturnNegotiatedSpecifications" (optional.Bool) -  Return the transformed specifications in response or not. If not supplied defaults to false


*/

type NegotiationContractsApiApiContractsIdentifierPutOpts struct { 
	ClientRequestSource optional.String
	CpqLanguage optional.String
	PerformTransformation optional.Bool
	ReturnNegotiatedSpecifications optional.Bool
}

func (a *NegotiationContractsApiService) ApiContractsIdentifierPut(ctx context.Context, fcUser string, identifier string, contract ContractModel, contentType string, localVarOptionals *NegotiationContractsApiApiContractsIdentifierPutOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/contracts/{identifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", fmt.Sprintf("%v", identifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(fcUser) < 1 {
		return nil, reportError("fcUser must have at least 1 elements")
	}
	if strlen(fcUser) > 30 {
		return nil, reportError("fcUser must have less than 30 elements")
	}

	if localVarOptionals != nil && localVarOptionals.PerformTransformation.IsSet() {
		localVarQueryParams.Add("performTransformation", parameterToString(localVarOptionals.PerformTransformation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnNegotiatedSpecifications.IsSet() {
		localVarQueryParams.Add("returnNegotiatedSpecifications", parameterToString(localVarOptionals.ReturnNegotiatedSpecifications.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	localVarHeaderParams["fc-user"] = parameterToString(fcUser, "")
	if localVarOptionals != nil && localVarOptionals.CpqLanguage.IsSet() {
		localVarHeaderParams["cpq-language"] = parameterToString(localVarOptionals.CpqLanguage.Value(), "")
	}
	localVarHeaderParams["Content-Type"] = parameterToString(contentType, "")
	// body params
	localVarPostBody = &contract
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NegotiationContractsApiService
Query the referenced offerings and standalone discounts on the framework contract with the specified rule set to identify those specification structures which can be used to generate selection rules. The data is returned in a hierarchical format for each offering or standalone discount.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identifier The identifier of a contract rule set for which you wish to return the referenced specification items which can converted into selection rules. This identifier can be provided either as a guid value or as a value which matches the pattern ^[a-z0-9]{6}$
 * @param optional nil or *NegotiationContractsApiApiContractsIdentifierSelectableItemsGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "CpqLanguage" (optional.String) -  The language code (in ISO 639-1 format) that error messages are to be translated to for returning back to the client. If not supplied it defaults to en-GB


*/

type NegotiationContractsApiApiContractsIdentifierSelectableItemsGetOpts struct { 
	ClientRequestSource optional.String
	CpqLanguage optional.String
}

func (a *NegotiationContractsApiService) ApiContractsIdentifierSelectableItemsGet(ctx context.Context, identifier string, localVarOptionals *NegotiationContractsApiApiContractsIdentifierSelectableItemsGetOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/contracts/{identifier}/selectableItems"
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", fmt.Sprintf("%v", identifier), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.CpqLanguage.IsSet() {
		localVarHeaderParams["cpq-language"] = parameterToString(localVarOptionals.CpqLanguage.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NegotiationContractsApiService
Retrieve the details on the contract rule set which matches the supplied identifier and status.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param identifier The identifier of a contract rule set - can be provided either as a guid value or as a value which matches the pattern ^[a-z0-9]{6}$
 * @param status The status value which matching rule sets should have
 * @param optional nil or *NegotiationContractsApiApiContractsIdentifierStatusStatusGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "CpqLanguage" (optional.String) -  The language code (in ISO 639-1 format) that error messages are to be translated to for returning back to the client. If not supplied it defaults to en-GB


*/

type NegotiationContractsApiApiContractsIdentifierStatusStatusGetOpts struct { 
	ClientRequestSource optional.String
	CpqLanguage optional.String
}

func (a *NegotiationContractsApiService) ApiContractsIdentifierStatusStatusGet(ctx context.Context, identifier string, status string, localVarOptionals *NegotiationContractsApiApiContractsIdentifierStatusStatusGetOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/contracts/{identifier}/status/{status}"
	localVarPath = strings.Replace(localVarPath, "{"+"identifier"+"}", fmt.Sprintf("%v", identifier), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"status"+"}", fmt.Sprintf("%v", status), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.CpqLanguage.IsSet() {
		localVarHeaderParams["cpq-language"] = parameterToString(localVarOptionals.CpqLanguage.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NegotiationContractsApiService
Create a framework contract rule and create negotiated specifications for the referenced offering and standalone discount specifications
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param fcUser The name of the user that is creating the framework contract rule set
 * @param contract The framework contract rule set in JSON format that is to be written to the database.
 * @param contentType Specifies the format of the data that is being sent to the API. Only JSON data is accepted
 * @param optional nil or *NegotiationContractsApiApiContractsPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "CpqLanguage" (optional.String) -  The language code (in ISO 639-1 format) that error messages are to be translated to for returning back to the client. If not supplied it defaults to en-GB
     * @param "PerformTransformation" (optional.Bool) -  Perform transformation of referenced product specifications using the given framework contract into transformed specifications or not. If not supplied defaults to true
     * @param "ReturnNegotiatedSpecifications" (optional.Bool) -  Return the transformed specifications in response or not. If not supplied defaults to false


*/

type NegotiationContractsApiApiContractsPostOpts struct { 
	ClientRequestSource optional.String
	CpqLanguage optional.String
	PerformTransformation optional.Bool
	ReturnNegotiatedSpecifications optional.Bool
}

func (a *NegotiationContractsApiService) ApiContractsPost(ctx context.Context, fcUser string, contract CreateContractModel, contentType string, localVarOptionals *NegotiationContractsApiApiContractsPostOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/contracts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if strlen(fcUser) < 1 {
		return nil, reportError("fcUser must have at least 1 elements")
	}
	if strlen(fcUser) > 30 {
		return nil, reportError("fcUser must have less than 30 elements")
	}

	if localVarOptionals != nil && localVarOptionals.PerformTransformation.IsSet() {
		localVarQueryParams.Add("performTransformation", parameterToString(localVarOptionals.PerformTransformation.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ReturnNegotiatedSpecifications.IsSet() {
		localVarQueryParams.Add("returnNegotiatedSpecifications", parameterToString(localVarOptionals.ReturnNegotiatedSpecifications.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	localVarHeaderParams["fc-user"] = parameterToString(fcUser, "")
	if localVarOptionals != nil && localVarOptionals.CpqLanguage.IsSet() {
		localVarHeaderParams["cpq-language"] = parameterToString(localVarOptionals.CpqLanguage.Value(), "")
	}
	localVarHeaderParams["Content-Type"] = parameterToString(contentType, "")
	// body params
	localVarPostBody = &contract
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
NegotiationContractsApiService
Retrieve the details of all contract rule sets which match the supplied status value
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param status The status value which matching rule sets should have
 * @param optional nil or *NegotiationContractsApiApiContractsStatusStatusGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "CpqLanguage" (optional.String) -  The language code (in ISO 639-1 format) that error messages are to be translated to for returning back to the client. If not supplied it defaults to en-GB
     * @param "FullDocument" (optional.Bool) -  If true then the contract rule set will return the details of the offerings and selection rules in the response otherwise just the top level top level rule set details will be returned


*/

type NegotiationContractsApiApiContractsStatusStatusGetOpts struct { 
	ClientRequestSource optional.String
	CpqLanguage optional.String
	FullDocument optional.Bool
}

func (a *NegotiationContractsApiService) ApiContractsStatusStatusGet(ctx context.Context, status string, localVarOptionals *NegotiationContractsApiApiContractsStatusStatusGetOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/contracts/status/{status}"
	localVarPath = strings.Replace(localVarPath, "{"+"status"+"}", fmt.Sprintf("%v", status), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.FullDocument.IsSet() {
		localVarQueryParams.Add("fullDocument", parameterToString(localVarOptionals.FullDocument.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	if localVarOptionals != nil && localVarOptionals.CpqLanguage.IsSet() {
		localVarHeaderParams["cpq-language"] = parameterToString(localVarOptionals.CpqLanguage.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}
