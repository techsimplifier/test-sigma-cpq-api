
/*
 * CPQ
 *
 * CPQ Web API Documentation
 *
 * API version: 2.9.1
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package swagger

import (
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type QuotesApiService service

/* 
QuotesApiService
This API allows us to post a &#x60;quote&#x60; object that is to be saved to the DB, the quote is validated against the schema and then it is wrote to the DB only after utilising catalog services validation and pricing for the Quote.   If a failed response is returned by the API, the responseCode value contains:   responseCode | Meaning   --- | ----   InvalidQuoteId | The quote Id provided is not a valid guid   QuoteFailedSchemaValidation | The quote supplied is a json structure, but is not a Quote
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quote The Quote Object
 * @param optional nil or *QuotesApiApiQuotesPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server..
     * @param "Include" (optional.String) -  Comma separated list of parameters to return on the quote. List of available options are: specification, candidate, validation, pricing, quote. Leaving blank would omit the include params from the quote.

@return CreateQuoteResponse
*/

type QuotesApiApiQuotesPostOpts struct { 
	ClientRequestSource optional.String
	Include optional.String
}

func (a *QuotesApiService) ApiQuotesPost(ctx context.Context, quote CreteQuoteBody, localVarOptionals *QuotesApiApiQuotesPostOpts) (CreateQuoteResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue CreateQuoteResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &quote
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v CreateQuoteResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v InvalidQuoteId400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v QuoteFailedSchemaValidationErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Post a attachment to be created in CPQ&#39;s datastore that is referenced to the given quoteId
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote
 * @param attachmentLink The details of the new attachment link to create
 * @param optional nil or *QuotesApiApiQuotesQuoteIdAttachmentLinkPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return AttachmentLink
*/

type QuotesApiApiQuotesQuoteIdAttachmentLinkPostOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdAttachmentLinkPost(ctx context.Context, quoteId string, attachmentLink AttachmentLink, localVarOptionals *QuotesApiApiQuotesQuoteIdAttachmentLinkPostOpts) (AttachmentLink, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AttachmentLink
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/attachmentLink"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &attachmentLink
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AttachmentLink
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets an array of attachmentLinks for the given quote id. A plugin can be registered to provide attachment links from an external system, these will be combined with attachmentLinks retrieved from CPQ datastore. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdAttachmentLinksGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return AttachmentLinks
*/

type QuotesApiApiQuotesQuoteIdAttachmentLinksGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdAttachmentLinksGet(ctx context.Context, quoteId string, localVarOptionals *QuotesApiApiQuotesQuoteIdAttachmentLinksGetOpts) (AttachmentLinks, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue AttachmentLinks
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/attachmentLinks"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v AttachmentLinks
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets the DataValue from the contextData for the given contextKey. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param contextKey Context Key
 * @param optional nil or *QuotesApiApiQuotesQuoteIdContextDataContextKeyGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return Quote
*/

type QuotesApiApiQuotesQuoteIdContextDataContextKeyGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdContextDataContextKeyGet(ctx context.Context, quoteId string, contextKey string, localVarOptionals *QuotesApiApiQuotesQuoteIdContextDataContextKeyGetOpts) (Quote, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Quote
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/contextData/{contextKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contextKey"+"}", fmt.Sprintf("%v", contextKey), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Quote
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v InternalServerError500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Puts the DataValue in the contextData for the given contextKey. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param contextKey Context Key
 * @param contextDataValue Context Object to be updated/inserted, To update just a string, the body should have a key named as &#39;value&#39;. e.g. {&#39;value&#39;:&#39;XYZ VALUE&#39;}
 * @param optional nil or *QuotesApiApiQuotesQuoteIdContextDataContextKeyPutOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return interface{}
*/

type QuotesApiApiQuotesQuoteIdContextDataContextKeyPutOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdContextDataContextKeyPut(ctx context.Context, quoteId string, contextKey string, contextDataValue ContextDataValueRequestBody, localVarOptionals *QuotesApiApiQuotesQuoteIdContextDataContextKeyPutOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/contextData/{contextKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"contextKey"+"}", fmt.Sprintf("%v", contextKey), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &contextDataValue
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v InternalServerError500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets the contextData for the given quote id. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdContextDataGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return Quote
*/

type QuotesApiApiQuotesQuoteIdContextDataGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdContextDataGet(ctx context.Context, quoteId string, localVarOptionals *QuotesApiApiQuotesQuoteIdContextDataGetOpts) (Quote, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Quote
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/contextData"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Quote
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v InternalServerError500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
This API adds or replaces &#39;contextData&#39; on the quote. This can be used to store contextual information about the quote on the quotes &#39;contextData&#39; property. &lt;/b&gt; If a failed response is returned by the API, the responseCode value contains:  responseCode | Meaning   --- | ----  InvalidQuoteId | The quote Id provided is not a valid guid
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId The unique Identifier of the quote that needs to be updated
 * @param requestBody The context data object. This object will replace the one already with the Quote. The &#39;ContextData&#39; object has no structure/schema defined. This is a custom defined object and can have a custom defined structure/schema.
 * @param optional nil or *QuotesApiApiQuotesQuoteIdContextDataPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return interface{}
*/

type QuotesApiApiQuotesQuoteIdContextDataPostOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdContextDataPost(ctx context.Context, quoteId string, requestBody PostContextDataRequestBody, localVarOptionals *QuotesApiApiQuotesQuoteIdContextDataPostOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/contextData"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &requestBody
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v ContextErrorResponse400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v InternalServerError500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
This API is responsible for updating the &#39;contextData&#39; object on the DB for the given quote by merging the supplied context data with any pre-existing data. This merge replaces any values common between the two with the newer data, and otherwise adds new values to the old object as supplied. &lt;/b&gt; If a failed response is returned by the API, the responseCode value contains:  responseCode | Meaning   --- | ----  InvalidQuoteId | The quote Id provided is not a valid guid DataAccessNoQuoteData | There was a problem accessing the quote data DataUpdateErrorEx | Error updating collection Quotes. The error is MongoError
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Supply a valid guid for quoteId and it should be present in the CPQ system.&lt;br/&gt;Example:841b8d04-2c18-44c4-aa18-a3ae0fc17558
 * @param requestBody The context data object.The &#39;ContextData&#39; object has no structure/schema defined. This is a custom defined object and can have a custom defined structure/schema.
 * @param optional nil or *QuotesApiApiQuotesQuoteIdContextDataPutOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return interface{}
*/

type QuotesApiApiQuotesQuoteIdContextDataPutOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdContextDataPut(ctx context.Context, quoteId string, requestBody PutContextDataRequestBody, localVarOptionals *QuotesApiApiQuotesQuoteIdContextDataPutOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/contextData"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &requestBody
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v ContextErrorResponse400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v ContextErrorResponse500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
This API is used to convert a quote to an order. &lt;/b&gt; A new quote is generated with type 3 (type order) and has a populated order object. &lt;/b&gt; The original quote id is pushed to the order quotes quoteHistory array. &lt;/b&gt; The id of the new generate order quote is returned in the response.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId The unique identifier of the quote to be converted to an order
 * @param requestBody The Request body containing data such as the quoteLastUpdated property &lt;/b&gt; An optional &#39;externalOrderId&#39; can also be added to the body, which will be added to the context data of the new order if provided. This is usually provided when dealing with an external CRM system
 * @param optional nil or *QuotesApiApiQuotesQuoteIdConvertToOrderPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return QuoteConvert200Response
*/

type QuotesApiApiQuotesQuoteIdConvertToOrderPostOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdConvertToOrderPost(ctx context.Context, quoteId string, requestBody PostConvertToOrderDataRequestBody, localVarOptionals *QuotesApiApiQuotesQuoteIdConvertToOrderPostOpts) (QuoteConvert200Response, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue QuoteConvert200Response
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/convertToOrder"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &requestBody
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v QuoteConvert200Response
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v QuoteConvert400Error
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 401 {
			var v UnauthorizedRequest401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 403 {
			var v ConvertToOrderForbiddenError403
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 404 {
			var v QuoteConvert404Error
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Post a request to duplicate the given quote and optionally set a new quoteType (supplied in the body of the request) If no quoteType is supplied it will default to the same value as source quote. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote to duplicate
 * @param optional nil or *QuotesApiApiQuotesQuoteIdCopyPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "Trigger" (optional.String) -  The source that called the copy operation
     * @param "QuoteType" (optional.Interface of QuoteType) -  The quoteType (enum value) to set on the duplicated quote

@return QuoteCopyResponse
*/

type QuotesApiApiQuotesQuoteIdCopyPostOpts struct { 
	ClientRequestSource optional.String
	Trigger optional.String
	QuoteType optional.Interface
}

func (a *QuotesApiService) ApiQuotesQuoteIdCopyPost(ctx context.Context, quoteId string, localVarOptionals *QuotesApiApiQuotesQuoteIdCopyPostOpts) (QuoteCopyResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue QuoteCopyResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Trigger.IsSet() {
		localVarQueryParams.Add("trigger", parameterToString(localVarOptionals.Trigger.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.QuoteType.IsSet() {
		
		localVarOptionalQuoteType, localVarOptionalQuoteTypeok := localVarOptionals.QuoteType.Value().(QuoteType)
		if !localVarOptionalQuoteTypeok {
				return localVarReturnValue, nil, reportError("quoteType should be QuoteType")
		}
		localVarPostBody = &localVarOptionalQuoteType
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v QuoteCopyResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Delete the specified &#x60;Quote&#x60; object from the DB 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote to delete
 * @param deleteQuoteRequest last updated date of quote
 * @param optional nil or *QuotesApiApiQuotesQuoteIdDeleteOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.


*/

type QuotesApiApiQuotesQuoteIdDeleteOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdDelete(ctx context.Context, quoteId string, deleteQuoteRequest DeleteQuoteRequest, localVarOptionals *QuotesApiApiQuotesQuoteIdDeleteOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &deleteQuoteRequest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v QuoteDataMisMatch
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 401 {
			var v UnauthorizedRequest401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 403 {
			var v DeleteQuoteForbiddenError403
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 409 {
			var v ConflictErrorConvertedQuote
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v InternalServerError500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
QuotesApiService
This API is responsible for fetching the financial summary data associated to the quote
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId entity ID
 * @param financialSummaryQuery Query that will be executed by the financial summary plugin   pluginToExecuteIdentifier: The id of the registered financialSummary plugin that will be executed  groupBy: Supported values are quoteItem and location  optionsToInclude: This object is used to control how many of the grids are returned by the API  The below example will return the totals summary, and all containers with the breakdownSummary and Breakdown for every quote item within the quote  To only request the Quote totals grid, delete the containers object that contains the breakdownSummary and breakdown objects  To request the Totals summary and all of the breakdownSummary grids, delete the breakdown object within the containers object  To request the breakdown grid for just one (or more) quote item or location, remove the totalSummary and breakdownSummary object, and add an ids array to the containers object with one (or more) of the ids of the quoteItems/Locations (depending if the groupBy is set to location or quote item)  The ids array is used to filter the number of containers that are returned from the server, by including the quote item or location ids that are only required  Not addng the ids array will tell server to return a container for every quote item/location for the quote in question
 * @param optional nil or *QuotesApiApiQuotesQuoteIdFinancialSummaryPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return FinancialSummaryResponse
*/

type QuotesApiApiQuotesQuoteIdFinancialSummaryPostOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdFinancialSummaryPost(ctx context.Context, quoteId string, financialSummaryQuery FinancialSummaryQuery, localVarOptionals *QuotesApiApiQuotesQuoteIdFinancialSummaryPostOpts) (FinancialSummaryResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue FinancialSummaryResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/financialSummary"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &financialSummaryQuery
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v FinancialSummaryResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets a Generic Order representation of the given quote (from quoteId) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId The unique identifier of the quote that the generic order should be generated from
 * @param optional nil or *QuotesApiApiQuotesQuoteIdGenericOrderGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return GenericOrder
*/

type QuotesApiApiQuotesQuoteIdGenericOrderGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdGenericOrderGet(ctx context.Context, quoteId string, localVarOptionals *QuotesApiApiQuotesQuoteIdGenericOrderGetOpts) (GenericOrder, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GenericOrder
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/genericOrder"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v GenericOrder
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
This API is responsible for fetching a quote structure, when no include options are provided the route returns minimal information by giving the route a set of includeParams the route will return extra information, such as specification and candidate structures. The API supports include criteria such as specification, candidate, validation, pricing and quote to control the object returned. &lt;/b&gt;&lt;br/&gt; If a failed response is returned by the API, the responseCode value contains:  responseCode | Meaning   --- | ----   DataAccessNoQuoteData |There was a problem accessing the quote data, it is not a quote in the CPQ system  InvalidQuoteId | The quote Id provided is not a valid guid
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId A guid of the quoteId representing the quote object to be returned in the request.&lt;br/&gt;Example:841b8d04-2c18-44c4-aa18-a3ae0fc17558
 * @param optional nil or *QuotesApiApiQuotesQuoteIdGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "Include" (optional.String) -  Comma separated list of parameters to return on the quote. List of available options are: specification, candidate, validation, pricing, quote. Leaving blank would omit the include params from the quote.&lt;br&gt;Example:pricing,candidate,specification,validation

@return GetQuoteSuccessResponse200
*/

type QuotesApiApiQuotesQuoteIdGetOpts struct { 
	ClientRequestSource optional.String
	Include optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdGet(ctx context.Context, quoteId string, localVarOptionals *QuotesApiApiQuotesQuoteIdGetOpts) (GetQuoteSuccessResponse200, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GetQuoteSuccessResponse200
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v GetQuoteSuccessResponse200
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v GetQuoteErrorResponse400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 404 {
			var v GetQuoteErrorResponse404
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v InternalServerError500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Post  a &#x60;QuoteItem&#x60; that specifies a portfolioItemId and full quoteItem is generated to be saved to the given quote in the DB 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote to save the quoteItem to
 * @param quoteItem The quoteItem object containing the portfolioItemId
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemFromPortfolioPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return QuoteItem
*/

type QuotesApiApiQuotesQuoteIdItemFromPortfolioPostOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemFromPortfolioPost(ctx context.Context, quoteId string, quoteItem PortfolioItem, localVarOptionals *QuotesApiApiQuotesQuoteIdItemFromPortfolioPostOpts) (QuoteItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue QuoteItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/itemFromPortfolio"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &quoteItem
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v QuoteItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
POST a sparse request to create a sparse quote item from given minimal configured inputs.  Sparse API enables an API caller to create a Quote Item on a Quote where the caller is not required to provide the full quote item and quote structures. You only need to specify key pieces of data identifying the main selectable items of an offering to allow CPQ to determine the structure of the quote item.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Supply a valid guid for quoteId and it should be present in the CPQ system.&lt;br/&gt;Example:841b8d04-2c18-44c4-aa18-a3ae0fc17558
 * @param offerGuid unique offer id of the offer
 * @param sparseRequestBody The sparse request body used for sparse create quoteItem
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsFromSelectionsPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return SparseCreateQuoteItemResponse
*/

type QuotesApiApiQuotesQuoteIdItemsFromSelectionsPostOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsFromSelectionsPost(ctx context.Context, quoteId string, offerGuid string, sparseRequestBody SparseRequest, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsFromSelectionsPostOpts) (SparseCreateQuoteItemResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue SparseCreateQuoteItemResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/fromSelections"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("offerGuid", parameterToString(offerGuid, ""))
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &sparseRequestBody
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v SparseCreateQuoteItemResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Posts a request that duplicates a quote item a given number of times &lt;/br&gt; This requests begins a copy job on the server which will eventually call back to the given call back url with a success or failure. &lt;/br&gt; This route returns a JobId that represents the job running the copies. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote that contains the item to duplicate
 * @param itemId ID of the quote item to be duplicated
 * @param copyBody The copy object indicating &#39;copyCount&#39;, &#39;callbackVerb&#39; and &#39;callbackUrl&#39; for which the endpoint will respond after attempting to copy.
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsItemIdCopyManyPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return string
*/

type QuotesApiApiQuotesQuoteIdItemsItemIdCopyManyPostOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsItemIdCopyManyPost(ctx context.Context, quoteId string, itemId string, copyBody string, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsItemIdCopyManyPostOpts) (string, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue string
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/{itemId}/copyMany"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", fmt.Sprintf("%v", itemId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &copyBody
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v string
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Post a request to duplicate the specified quote item. &lt;br/&gt; It will replace the unique Id&#39;s contained within the product candidate and provide a new quoteItem ID and itemNumber. &lt;br/&gt; If the source quoteItem contains LinkedEntities then you will get an error as these are not supported. &lt;br/&gt; An optional parameter for the quote item name can be passed in the request body.  
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote that contains the item to duplicate
 * @param itemId ID of the quote item to be duplicated
 * @param copyQuoteItem The request body of copy quote item
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsItemIdCopyPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return QuoteItemCopy200
*/

type QuotesApiApiQuotesQuoteIdItemsItemIdCopyPostOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsItemIdCopyPost(ctx context.Context, quoteId string, itemId string, copyQuoteItem QuoteItemCopy, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsItemIdCopyPostOpts) (QuoteItemCopy200, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue QuoteItemCopy200
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/{itemId}/copy"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", fmt.Sprintf("%v", itemId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &copyQuoteItem
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v QuoteItemCopy200
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Returns a subset of the current configuration and pricing of a quote item, along with selected specification properties. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote that contains the quote item
 * @param itemId the ID of the quote item to summarise
 * @param specificationPropertySelection The types and properties from the product specification to include in the summary. May be empty
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsItemIdCurrentConfigurationPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "ReturnAs" (optional.String) -  the returnAs flag is to be set to &#39;flat&#39; if  you want a flat structure in response 

@return interface{}
*/

type QuotesApiApiQuotesQuoteIdItemsItemIdCurrentConfigurationPostOpts struct { 
	ClientRequestSource optional.String
	ReturnAs optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsItemIdCurrentConfigurationPost(ctx context.Context, quoteId string, itemId string, specificationPropertySelection SpecSelectByType, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsItemIdCurrentConfigurationPostOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/{itemId}/currentConfiguration"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", fmt.Sprintf("%v", itemId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.ReturnAs.IsSet() {
		localVarQueryParams.Add("returnAs", parameterToString(localVarOptionals.ReturnAs.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &specificationPropertySelection
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Delete the specified &#x60;QuoteItem&#x60; object from the DB 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote that contains the quote item
 * @param itemId the ID of the quote item to delete quote item
 * @param deleteQuoteItemRequest last updated date of quote
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsItemIdDeleteOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return Quote
*/

type QuotesApiApiQuotesQuoteIdItemsItemIdDeleteOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsItemIdDelete(ctx context.Context, quoteId string, itemId string, deleteQuoteItemRequest DeleteQuoteItemRequest, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsItemIdDeleteOpts) (Quote, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Delete")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Quote
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", fmt.Sprintf("%v", itemId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &deleteQuoteItemRequest
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Quote
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v QuoteDataMisMatch
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 401 {
			var v UnauthorizedRequest401
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 403 {
			var v DeleteQuoteItemForbiddenError403
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 409 {
			var v ConflictErrorConvertedQuoteItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Post a &#39;QuoteItem&#39; to be decomposed, validated and priced, but without being saved to the datastore
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId The unique identifier of the quote that the POSTed quote item belongs to
 * @param itemId The unique identifier of the quote item that is being POSTed
 * @param quoteItem The quote item structure to be decomposed, validated and priced
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsItemIdEvaluateRulesPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return QuoteItem
*/

type QuotesApiApiQuotesQuoteIdItemsItemIdEvaluateRulesPostOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsItemIdEvaluateRulesPost(ctx context.Context, quoteId string, itemId string, quoteItem QuoteItem, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsItemIdEvaluateRulesPostOpts) (QuoteItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue QuoteItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/{itemId}/evaluateRules"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", fmt.Sprintf("%v", itemId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &quoteItem
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v QuoteItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets the quote item (from itemId) from the given quote (from quoteId) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param itemId Item ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsItemIdGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "Include" (optional.String) -  Comma separated list of parameters to return on the quote item. List of available options are: specification, candidate, validation, pricing, quote. Leaving it blank would omit the include params from each item.

@return QuoteItem
*/

type QuotesApiApiQuotesQuoteIdItemsItemIdGetOpts struct { 
	ClientRequestSource optional.String
	Include optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsItemIdGet(ctx context.Context, quoteId string, itemId string, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsItemIdGetOpts) (QuoteItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue QuoteItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", fmt.Sprintf("%v", itemId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v QuoteItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets the price for the given quoteItem (itemId) on the given quote (quoteId). 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param itemId Item ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsItemIdPricingGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return interface{}
*/

type QuotesApiApiQuotesQuoteIdItemsItemIdPricingGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsItemIdPricingGet(ctx context.Context, quoteId string, itemId string, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsItemIdPricingGetOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/{itemId}/pricing"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", fmt.Sprintf("%v", itemId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Put an updated &#x60;QuoteItem&#x60; object to the DB for the given quote 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote that contains the quote item
 * @param itemId the ID of the quote item to update
 * @param quoteItem The updated quote item
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsItemIdPutOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "Include" (optional.String) -  Comma separated list of parameters to return on the quote item. List of available options are: specification, candidate, validation, pricing, quote. Leaving it blank would omit the include params from each item.

@return QuoteItem
*/

type QuotesApiApiQuotesQuoteIdItemsItemIdPutOpts struct { 
	ClientRequestSource optional.String
	Include optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsItemIdPut(ctx context.Context, quoteId string, itemId string, quoteItem QuoteItem, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsItemIdPutOpts) (QuoteItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue QuoteItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", fmt.Sprintf("%v", itemId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &quoteItem
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v QuoteItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Updates the &#39;name&#39; property on a quote item object, only the &#39;name&#39; property is required, you can provide the whole object and we will just use the &#39;name&#39; property. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote
 * @param itemId ID of the quote item
 * @param quoteItem The quote item to update
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsItemIdQuoteItemNamePutOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return UpdatedQuoteItem
*/

type QuotesApiApiQuotesQuoteIdItemsItemIdQuoteItemNamePutOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsItemIdQuoteItemNamePut(ctx context.Context, quoteId string, itemId string, quoteItem PutQuoteItemName, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsItemIdQuoteItemNamePutOpts) (UpdatedQuoteItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UpdatedQuoteItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/{itemId}/quoteItemName"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", fmt.Sprintf("%v", itemId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &quoteItem
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v UpdatedQuoteItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v InvalidQuoteItemName400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 404 {
			var v DataAccessNoQuoteItemData404
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
The purpose of this endpoint is to return related offers to the selected quote item, the returned types of offers are defined by the RelationTypes parameter, this will return all the configured offers against the specified quote item for which there is a RelationTypes parameter. &lt;/b&gt; If a failed response is returned by the API, the responseCode value contains:  responseCode | Meaning   --- | ----  InvalidQuoteId | The quote Id provided is not a valid guid DataAccessNoQuoteData | There was a problem accessing the quote datan  MissingGetRelatedOfferParams | RelationTypes and RequestType are required query parameters to get related offers
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param itemId Item ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsItemIdRelatedOffersGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "RelationTypes" (optional.String) -  Comma separated list of parameters, which types of related offers are to be returned eg. Cross-Sell types, or Up-Sell types etc. List of available options are: &lt;b&gt;TCrossSell,TUpsell. &lt;/b&gt; Leaving it blank would return an MissingGetRelatedOfferParams Error.
     * @param "RequestType" (optional.String) -  List of available option are: &lt;b&gt;Types. &lt;/b&gt; this can be either &#39;elements&#39; or &#39;types&#39; Leaving it blank would return an MissingGetRelatedOfferParams Error.

@return RelatedOffers
*/

type QuotesApiApiQuotesQuoteIdItemsItemIdRelatedOffersGetOpts struct { 
	ClientRequestSource optional.String
	RelationTypes optional.String
	RequestType optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsItemIdRelatedOffersGet(ctx context.Context, quoteId string, itemId string, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsItemIdRelatedOffersGetOpts) (RelatedOffers, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue RelatedOffers
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/{itemId}/relatedOffers"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", fmt.Sprintf("%v", itemId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.RelationTypes.IsSet() {
		localVarQueryParams.Add("RelationTypes", parameterToString(localVarOptionals.RelationTypes.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.RequestType.IsSet() {
		localVarQueryParams.Add("RequestType", parameterToString(localVarOptionals.RequestType.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v RelatedOffers
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v InvalidQuoteId400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 404 {
			var v DataAccessNoQuoteItemData404
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v MissingGetRelatedOfferParams500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
The purpose of the API is to raise the Quote Item Updated event using event framework.  &lt;/b&gt; For any invalid parameter API will send 404 for QuoteItemSynchronizeParameterError
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId The unique Identifier of the quote
 * @param itemId The unique Identifier of the quoteItem that needs to be synchronize
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsItemIdSynchronizePutOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.


*/

type QuotesApiApiQuotesQuoteIdItemsItemIdSynchronizePutOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsItemIdSynchronizePut(ctx context.Context, quoteId string, itemId string, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsItemIdSynchronizePutOpts) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/{itemId}/synchronize"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", fmt.Sprintf("%v", itemId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 404 {
			var v QuoteItemSynchronizeParameterErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v InternalServerError500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets the current validation for the given quote item (from itemId) on the given quote (from quoteId) and returns it on the quoteItem object 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param itemId Item ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsItemIdValidateGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return QuoteItem
*/

type QuotesApiApiQuotesQuoteIdItemsItemIdValidateGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsItemIdValidateGet(ctx context.Context, quoteId string, itemId string, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsItemIdValidateGetOpts) (QuoteItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue QuoteItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items/{itemId}/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", fmt.Sprintf("%v", itemId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v QuoteItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
The end-point is responsible for adding a new quoteItem to the quote. The API takes a quoteId and a quoteItem structure, this route will add the quoteItem to the referenced quote. This API also allows us to pass the parameters that are to be returned with the quoteItem, like &lt;b&gt; specification, candidate, validation, pricing&lt;/b&gt; and &lt;b&gt; quote&lt;/b&gt;.  &lt;/b&gt; If a failed response is returned by the API, the responseCode value contains:  responseCode | Meaning   --- | ----   DataAccessNoQuoteData |There was a problem accessing the quote data, it is not a quote in the CPQ system  NoProductOrPortfolioItemId | The error occurs when there is no productId or PortfolioItemId provided in the request   InvalidQuoteId | The error occurs when the quote id provided is not a valid guid  
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote to post the quoteItem to
 * @param quoteItem The quoteItem object
 * @param optional nil or *QuotesApiApiQuotesQuoteIdItemsPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "Include" (optional.String) -  Comma separated list of parameters to return on the quote item. List of available options are: specification, candidate, validation, pricing, quote. Leaving it blank would omit the include params from each item. &lt;br/&gt;&lt;b&gt;example: - include&#x3D;candidate,validation,pricing&lt;/b&gt;

@return QuoteItem
*/

type QuotesApiApiQuotesQuoteIdItemsPostOpts struct { 
	ClientRequestSource optional.String
	Include optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdItemsPost(ctx context.Context, quoteId string, quoteItem QuoteItemCreateBody, localVarOptionals *QuotesApiApiQuotesQuoteIdItemsPostOpts) (QuoteItem, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue QuoteItem
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/items"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &quoteItem
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v QuoteItem
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v InvalidQuoteId400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 404 {
			var v PostQuoteItem404
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v InternalServerError500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets the offer specification for the given quoteId and offerId. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param offerId Offer ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdOfferSpecOfferIdGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return interface{}
*/

type QuotesApiApiQuotesQuoteIdOfferSpecOfferIdGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdOfferSpecOfferIdGet(ctx context.Context, quoteId string, offerId string, localVarOptionals *QuotesApiApiQuotesQuoteIdOfferSpecOfferIdGetOpts) (interface{}, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue interface{}
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/offerSpec/{offerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"offerId"+"}", fmt.Sprintf("%v", offerId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Retrieve the offers which match the supplied classifications, facts, characteristics and categories. A fully populated endpoint would look like:&lt;br/&gt;&lt;br/&gt;&lt;b&gt;/api/quotes/ffb05cbf-b0fe-466b-8a96-86b173ede039/offers?InstanceTypeNames&#x3D;Package&amp;Classifications&#x3D;[TSales_Channel_Classification;e4a2a606-501f-f009-731a-64ba27c59d50;false]&amp;ClassificationElementName&#x3D;TSales_Channel_Classification&amp;FactElementFilter&#x3D;[Lookup_Colour;fed70bc9-c12d-4875-b2d3-e1930992440e;false]&amp;Categories&#x3D;[22,18;true]&amp;Characteristics&#x3D;[Lookup_Colour;846fa97b-b9a5-4671-9660-f3b0d554da4b;false]&amp;xsltCode&#x3D;offer_short&amp;at[p1]&#x3D;ID&amp;el[p2]&#x3D;name&lt;/b&gt;&lt;br/&gt; If a failed response is returned by the API, the responseCode value contains:   responseCode | Meaning   --- | ----   ErrorConvertingClassificationOffers | An error occurred while attempting to convertClassificationOffers.  InvalidQuoteId | The quote ID provided is not a valid guid  CSConnectionRequestError | The request was sent to Catalog Services and failed in this component
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId A valid identifier of the quote.&lt;br/&gt;(Used to get the quote context information that will allow additional filter packets to be appended to those supplied.) example: - &#39;ffb05cbf-b0fe-466b-8a96-86b173ede039&#39;
 * @param instanceTypeNames Comma separated list of entity types you would like returned. These can include &lt;br/&gt;&lt;br/&gt;example:- &lt;br/&gt;Package,Bundle Promotion etc. &lt;br/&gt;&lt;br/&gt;Note that these types must be specified with the first letter capitalised. example: - &#39;Package&#39;
 * @param classificationElementName That name of the element on each entity you wish returned that is of the Classification type specified in the data packets example: - &#39;TSales_Channel_Classification&#39;
 * @param classifications A list of classification packets that define which classification on which to match.&lt;br/&gt; &lt;br/&gt;Format:&lt;br/&gt;[classificationElementName; classificationGuids; MatchAllClassification]&lt;br/&gt;&lt;br/&gt;classificationElementName: - is the name of the schema element that holds the Classifications to filter.&lt;br/&gt;&lt;br/&gt;classificationGuids: - is a comma-separated list that represents all the Classifications to filter.&lt;br/&gt;&lt;br/&gt;MatchAllClassification: - is either TRUE or FALSE, to match ALL of the query results or just ANY respectively. &lt;br/&gt;&lt;br/&gt;Note :- You can pass multiple packets into this query. example: - &#39;[TSales_Channel_Classification;e4a2a606-501f-f009-731a-64ba27c59d50;false]&#39;
 * @param xsltCode The code of the XSLT stored in the Catalog Services database that transforms the XML output into a desired format. This is required and must return data in the required format. example: - &#39;offer_short&#39;
 * @param optional nil or *QuotesApiApiQuotesQuoteIdOffersGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "Characteristics" (optional.String) -  A list of characteristic packets on which the query is filtering. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;Format for each packet:&lt;br/&gt;[characteristicElementName; characteristicGuids; MatchAllCharacteristics]&lt;/b&gt;&lt;br/&gt;&lt;br/&gt;&lt;b&gt;characteristicElementName: - &lt;/b&gt;name of the schema element that holds the characteristics.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;characteristicGuids: - &lt;/b&gt;is a comma-separated list that represents all the characteristics.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;MatchAllCharacteristics: -&lt;/b&gt; is either TRUE or FALSE to specify whether the query results need to match ALL of these or just ANY. &lt;br/&gt;&lt;br/&gt;&lt;b&gt; Note:- You can pass multiple packets into this query. Add multiple characteristic and classification packets by appending each element set inside square brackets ([ ]). Combine each additional packet with the others using AND logic to specify that all must match.&lt;b&gt; example: - &#39;[Lookup_Colour;846fa97b-b9a5-4671-9660-f3b0d554da4b;false]&#39;
     * @param "FactElementFilter" (optional.String) -  A list of fact values for those on which you want to query to match. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;Format:&lt;br/&gt;[FactValue; FactValueGuids; MatchAllFactValues]&gt;&lt;/b&gt;&lt;br/&gt;&lt;b&gt;FactValue: - &lt;/b&gt;is the name of the schema element that holds the fact value on which you are filtering.&lt;br/&gt;&lt;br/&gt; &lt;b&gt;FactValueGuids: - &lt;/b&gt;is a comma-separated list of GUIDs representing the fact values on which you are filtering. &lt;br/&gt;&lt;br/&gt;&lt;b&gt;MatchAllFactValues: -&lt;/b&gt;is a true or false value indicating whether the query matches on ALL fact values or just ANY fact values.&lt;br/&gt;&lt;br/&gt;&lt;b&gt;Note: You can pass multiple fact value packets in this query. example: - &#39;[Lookup_Colour;fed70bc9-c12d-4875-b2d3-e1930992440e;false]&#39;&lt;/b&gt;
     * @param "Categories" (optional.String) -  A data packet which takes the following format: &lt;br/&gt;[Categories;IncludeChildCategories].&lt;br/&gt;&lt;br/&gt; &lt;b&gt;Categories :-&lt;/b&gt; is a comma separated list of category Ids.&lt;br/&gt;&lt;br/&gt;&lt;b&gt; IncludeChildCategories :-&lt;/b&gt; indicates whether entities should be returned that live in categories that are children of the category Id specified in the CATEGORIES parameter. example: - &#39;[22,18;true]&#39;
     * @param "AtP1" (optional.String) -  &lt;b&gt;&#39;at&#39; means xslt attributes. &lt;/b&gt;A parameter in the parameter list for the above XSLT which are used to retrieve values which appear as XML attributes on a matching entity, there can be as many of these as you like as long as each key is unique, only one &#39;p1&#39; property.&lt;b&gt;Note: - You cannot have at[p1] and el[p1] every subsequent parameter should be incremented&lt;/b&gt; example: - &#39;ID&#39;
     * @param "AtP2" (optional.String) -  &lt;b&gt;&#39;at&#39; means xslt attributes. &lt;/b&gt; A parameter in the parameter list for the above XSLT which are used to retrieve values which appear as XML attributes on a matching entity, there can be as many of these as you like as long as each key is unique, only one &#39;p1&#39; property. example: - &#39;name&#39;
     * @param "AtP3" (optional.String) -  &lt;b&gt;&#39;at&#39; means xslt attributes. &lt;/b&gt; A parameter in the parameter list for the above XSLT which are used to retrieve values which appear as XML attributes on a matching entity, there can be as many of these as you like as long as each key is unique, only one &#39;p1&#39; property. example: - &#39;BusinessID&#39;
     * @param "ElP2" (optional.String) -  &lt;b&gt;&#39;el&#39; means xslt element. &lt;/b&gt;A parameter in the parameter list for the above XSLT which are used to retrieve values which appear as XML attributes on a matching entity, there can be as many of these as you like as long as each key is unique, only one &#39;p1&#39; property. example: - &#39;Name&#39;
     * @param "ElP3" (optional.String) -  &lt;b&gt;&#39;el&#39; means xslt element. &lt;/b&gt;A parameter in the parameter list for the above XSLT which are used to retrieve values which appear as XML attributes on a matching entity, there can be as many of these as you like as long as each key is unique, only one &#39;p1&#39; property.&lt;b&gt;Note: - You cannot have at[p1] and el[p1] every subsequent parameter should be incremented&lt;/b&gt; example: - &#39;marketingPrice&#39;
     * @param "ElP4" (optional.String) -  &lt;b&gt;&#39;el&#39; means xslt element. &lt;/b&gt; A parameter in the parameter list for the above XSLT which are used to retrieve values which appear as XML attributes on a matching entity, there can be as many of these as you like as long as each key is unique, only one &#39;p1&#39; property. example: - &#39;marketingDescription&#39;

@return GetOffersByClassificationResponse
*/

type QuotesApiApiQuotesQuoteIdOffersGetOpts struct { 
	ClientRequestSource optional.String
	Characteristics optional.String
	FactElementFilter optional.String
	Categories optional.String
	AtP1 optional.String
	AtP2 optional.String
	AtP3 optional.String
	ElP2 optional.String
	ElP3 optional.String
	ElP4 optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdOffersGet(ctx context.Context, quoteId string, instanceTypeNames string, classificationElementName string, classifications string, xsltCode string, localVarOptionals *QuotesApiApiQuotesQuoteIdOffersGetOpts) (GetOffersByClassificationResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue GetOffersByClassificationResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/offers"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarQueryParams.Add("InstanceTypeNames", parameterToString(instanceTypeNames, ""))
	localVarQueryParams.Add("ClassificationElementName", parameterToString(classificationElementName, ""))
	localVarQueryParams.Add("Classifications", parameterToString(classifications, ""))
	if localVarOptionals != nil && localVarOptionals.Characteristics.IsSet() {
		localVarQueryParams.Add("Characteristics", parameterToString(localVarOptionals.Characteristics.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.FactElementFilter.IsSet() {
		localVarQueryParams.Add("FactElementFilter", parameterToString(localVarOptionals.FactElementFilter.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Categories.IsSet() {
		localVarQueryParams.Add("Categories", parameterToString(localVarOptionals.Categories.Value(), ""))
	}
	localVarQueryParams.Add("xsltCode", parameterToString(xsltCode, ""))
	if localVarOptionals != nil && localVarOptionals.AtP1.IsSet() {
		localVarQueryParams.Add("at[p1]", parameterToString(localVarOptionals.AtP1.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AtP2.IsSet() {
		localVarQueryParams.Add("at[p2]", parameterToString(localVarOptionals.AtP2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.AtP3.IsSet() {
		localVarQueryParams.Add("at[p3]", parameterToString(localVarOptionals.AtP3.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElP2.IsSet() {
		localVarQueryParams.Add("el[p2]", parameterToString(localVarOptionals.ElP2.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElP3.IsSet() {
		localVarQueryParams.Add("el[p3]", parameterToString(localVarOptionals.ElP3.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ElP4.IsSet() {
		localVarQueryParams.Add("el[p4]", parameterToString(localVarOptionals.ElP4.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v GetOffersByClassificationResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v GetQuoteErrorResponse400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v ErrorConvertingClassificationOffers500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets an order candidate representation of the given quote (from quoteId) 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdOrderCandidateGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return OrderCandidateRequest
*/

type QuotesApiApiQuotesQuoteIdOrderCandidateGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdOrderCandidateGet(ctx context.Context, quoteId string, localVarOptionals *QuotesApiApiQuotesQuoteIdOrderCandidateGetOpts) (OrderCandidateRequest, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue OrderCandidateRequest
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/order-candidate"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v OrderCandidateRequest
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets the price for the given quoteId.&lt;br/&gt;By allowing execution of custom plugin if required
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdPricingGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return []ICpqPricingResponse
*/

type QuotesApiApiQuotesQuoteIdPricingGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdPricingGet(ctx context.Context, quoteId string, localVarOptionals *QuotesApiApiQuotesQuoteIdPricingGetOpts) ([]ICpqPricingResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue []ICpqPricingResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/pricing"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v []ICpqPricingResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Updates quote items in the database Quote, for each supplied quote item. Items not supplied will no be updated, no items will be added or deleted. An object containing quoteLastUpdated field is returned on success. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote to update
 * @param quoteItem The updated quote object
 * @param optional nil or *QuotesApiApiQuotesQuoteIdPutOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "OverrideSavedMeta" (optional.Bool) -  Boolean value to indicate if the server should override the hasBeenSavedInClient parameter. If set to true, hasBeenSavedInClient will be false, otherwise, it will be true. Defaults to false if not provided.

@return PutQuoteRequest
*/

type QuotesApiApiQuotesQuoteIdPutOpts struct { 
	ClientRequestSource optional.String
	OverrideSavedMeta optional.Bool
}

func (a *QuotesApiService) ApiQuotesQuoteIdPut(ctx context.Context, quoteId string, quoteItem Quote, localVarOptionals *QuotesApiApiQuotesQuoteIdPutOpts) (PutQuoteRequest, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue PutQuoteRequest
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.OverrideSavedMeta.IsSet() {
		localVarQueryParams.Add("overrideSavedMeta", parameterToString(localVarOptionals.OverrideSavedMeta.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &quoteItem
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v PutQuoteRequest
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v InternalServerError500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Updates the &#39;name&#39; property on a quote object, only the &#39;name&#39; property is required, you can provide the whole object and we will just use the &#39;name&#39; property. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote
 * @param quote The quote to update
 * @param optional nil or *QuotesApiApiQuotesQuoteIdQuoteNamePutOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return UpdateQuoteNameResponse
*/

type QuotesApiApiQuotesQuoteIdQuoteNamePutOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdQuoteNamePut(ctx context.Context, quoteId string, quote PutQuoteName, localVarOptionals *QuotesApiApiQuotesQuoteIdQuoteNamePutOpts) (UpdateQuoteNameResponse, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Put")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue UpdateQuoteNameResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/quoteName"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &quote
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v UpdateQuoteNameResponse
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v UpdateQuoteNameResponse400
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 404 {
			var v UpdateQuoteNameResponse404
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
This API is used by external CRM applications to revise an existing quote.  &lt;/b&gt; The existing quote with its items are duplicated with new ids. The new quote has its CRMQuoteVersion and CRMQuoteId set in the context data from the provided body data. The original quotes id is also pushed into the new quotes quoteHistory array. &lt;/b&gt; The original quote has its CRMVersion set as the provided newQuoteVersion - 1.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId The unique Identifier of the quote to be revised
 * @param quoteReviseBody The externalQuoteId and newQuoteVersion required to revise a quote


*/
func (a *QuotesApiService) ApiQuotesQuoteIdRevisePost(ctx context.Context, quoteId string, quoteReviseBody QuoteReviseBody) (*http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/revise"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	// body params
	localVarPostBody = &quoteReviseBody
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarHttpResponse, err
	}


	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 400 {
			var v QuoteRevise400Error
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 404 {
			var v QuoteRevise404Error
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 405 {
			var v QuoteLocked405
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v InternalServerError500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarHttpResponse, newErr
		}
		
		return localVarHttpResponse, newErr
	}

	return localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets an array of users that can be assigned to tasks. If no plugin is registered to retrieve the data then an empty array will be returned. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdTaskAssigneesGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return Assignees
*/

type QuotesApiApiQuotesQuoteIdTaskAssigneesGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdTaskAssigneesGet(ctx context.Context, quoteId string, localVarOptionals *QuotesApiApiQuotesQuoteIdTaskAssigneesGetOpts) (Assignees, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Assignees
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/taskAssignees"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Assignees
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets an array of tasks for the given quote id. If no plugin is registered to retrieve the data then an empty array will be returned. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdTasksGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return Tasks
*/

type QuotesApiApiQuotesQuoteIdTasksGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdTasksGet(ctx context.Context, quoteId string, localVarOptionals *QuotesApiApiQuotesQuoteIdTasksGetOpts) (Tasks, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Tasks
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Tasks
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Post a new task to be created in an external system via a plugin. If no plugin is registered to handle the creation then an error will be returned
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId ID of the quote
 * @param task The details of the new task to create
 * @param optional nil or *QuotesApiApiQuotesQuoteIdTasksPostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return Task
*/

type QuotesApiApiQuotesQuoteIdTasksPostOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdTasksPost(ctx context.Context, quoteId string, task Task, localVarOptionals *QuotesApiApiQuotesQuoteIdTasksPostOpts) (Task, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Task
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/tasks"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	localVarPostBody = &task
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Task
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 404 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v interface{}
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Performs validation and pricing for the given quote(from quoteId)
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdValidateAndPricePostOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "ValidateAndPrice" (optional.Interface of ValidateAndPrice) -  The request body of validate and price

@return ValidateAndPrice200
*/

type QuotesApiApiQuotesQuoteIdValidateAndPricePostOpts struct { 
	ClientRequestSource optional.String
	ValidateAndPrice optional.Interface
}

func (a *QuotesApiService) ApiQuotesQuoteIdValidateAndPricePost(ctx context.Context, quoteId string, localVarOptionals *QuotesApiApiQuotesQuoteIdValidateAndPricePostOpts) (ValidateAndPrice200, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Post")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ValidateAndPrice200
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/validateAndPrice"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	// body params
	if localVarOptionals != nil && localVarOptionals.ValidateAndPrice.IsSet() {
		
		localVarOptionalValidateAndPrice, localVarOptionalValidateAndPriceok := localVarOptionals.ValidateAndPrice.Value().(ValidateAndPrice)
		if !localVarOptionalValidateAndPriceok {
				return localVarReturnValue, nil, reportError("validateAndPrice should be ValidateAndPrice")
		}
		localVarPostBody = &localVarOptionalValidateAndPrice
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v ValidateAndPrice200
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets the current validation for the given quote (from quoteId) and returns it on the quote object including all the quote items and their current validation 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param quoteId Quote ID
 * @param optional nil or *QuotesApiApiQuotesQuoteIdValidateGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.

@return Quote
*/

type QuotesApiApiQuotesQuoteIdValidateGetOpts struct { 
	ClientRequestSource optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteIdValidateGet(ctx context.Context, quoteId string, localVarOptionals *QuotesApiApiQuotesQuoteIdValidateGetOpts) (Quote, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Quote
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/{quoteId}/validate"
	localVarPath = strings.Replace(localVarPath, "{"+"quoteId"+"}", fmt.Sprintf("%v", quoteId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Quote
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
QuotesApiService
Gets  the &#x60;Quote&#x60; object for the given quote sequence id. 
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param sequenceId Sequence Id for the quote
 * @param optional nil or *QuotesApiApiQuotesQuoteSequenceIdGetOpts - Optional Parameters:
     * @param "ClientRequestSource" (optional.String) -  The client request header that identifies which client had made a request to CPQ Server.
     * @param "Include" (optional.String) -  Comma separated list of parameters to return on the quote. List of available options are: specification, candidate, validation, pricing, quote. Leaving blank would omit the include params from the quote.

@return Quote
*/

type QuotesApiApiQuotesQuoteSequenceIdGetOpts struct { 
	ClientRequestSource optional.String
	Include optional.String
}

func (a *QuotesApiService) ApiQuotesQuoteSequenceIdGet(ctx context.Context, sequenceId string, localVarOptionals *QuotesApiApiQuotesQuoteSequenceIdGetOpts) (Quote, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue Quote
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/api/quotes/quote/{sequenceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sequenceId"+"}", fmt.Sprintf("%v", sequenceId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.Include.IsSet() {
		localVarQueryParams.Add("include", parameterToString(localVarOptionals.Include.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	if localVarOptionals != nil && localVarOptionals.ClientRequestSource.IsSet() {
		localVarHeaderParams["clientRequestSource"] = parameterToString(localVarOptionals.ClientRequestSource.Value(), "")
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			var v Quote
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		if localVarHttpResponse.StatusCode == 500 {
			var v InternalServerError500
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
